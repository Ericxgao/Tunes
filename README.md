# Tunes Project

This repository provides documentation and supporting templates for developers who want to make an official derivative for Tunes.

## Info

OpenSea: https://opensea.io/collection/tunesproject

Discord: https://discord.com/invite/S7tq8bUkAR

**Mainnet Addresses:**

Tunes Contract: https://etherscan.io/address/0xfa932d5cBbDC8f6Ed6D96Cc6513153aFa9b7487C

Tunes Metadata Contract: https://etherscan.io/address/0xD9692a84cC279a159305a4ef1A01eFab77B4Deb2

**Testnet Addresses:**

Tunes Contract: https://rinkeby.etherscan.io/address/0xfa932d5cBbDC8f6Ed6D96Cc6513153aFa9b7487C

Tunes Metadata Contract: https://rinkeby.etherscan.io/address/0x66B89E9cA3627341484403ECCE2F8A70B23e6E96

## TunesDerivative

**Note: You do not need to conform to this to make an official Tunes derivative. The only thing you need to conform to is IERC721Metadata: https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721Metadata**

This is a basic template used to create a standard ERC721 token that can be minted, sold and transferred. This contract expects a URI that either returns JSON directly or is a link to a JSON text dump. The metadata should be formatted as usual per OpenSea standards: https://docs.opensea.io/docs/metadata-standards

For example, Tunes returns a link which holds the following JSON data:
```
{
    "name": "The End Of An Identity", 
    "description": "Tunes are imaginative song titles generated by AI. Audio, cover art, artist name, and other functionalities are intentionally omitted for others to interpret and create. Feel free to use a Tune in any way you want.", 
    "image": "https://tunes.mypinata.cloud/ipfs/QmataXDM8MnA8uzug1ctS4RVVajXQmkUqHZGdcvVje4msN/1.png"
}
```

This derivative contract has a few special changes as well. Only Tunes owners are allowed to mint, and they'll only be able to claim token IDs that match the Tunes that they own. You can see this in `claim(uint256[] calldata tokenIds)`.

You will need some OpenZeppelin dependencies to compile this - you can use `npm i @openzeppelin/contracts` if you're in a hardhat environment.

The basic workflow for to deploy your assets to IPFS is to do the following:

1. Generate all your assets for each token, numbered 1-5000.
2. Upload all your assets to IPFS in a folder.
3. Get the hash of the folder you uploaded to.
4. Generate metadata that properly links to the assets you just uploaded. These files should have no extension and simply labeled the number of the token they correspond to.
5. Upload all your metadata to IPFS in a folder.
6. Deploy your contract (hardhat/truffle recommended).
7. Verify your contract.
6. Call `setBaseURI(string memory baseURI)` on the contract to point to the metadata folder.
7. Freeze the base URI if you'd like to prevent further base URI changes.

## TunesMetadata

This is a public contract used to link your new contract to the Tunes ecosystem. We built this in a way that lets you retroactively link a contract to Tunes.

Essentially, you're going to either directly set metadata for Tunes or link your contract. If this looks like a glorified database, it's because it is! It's a way for us to keep organized on all the derivatives created so that we can properly share them on our public viewer.

#### Architecture:

TunesMetadata creates a metadata collection for every unique address that calls `setDirectMetadata` or `setInheritedMetadata`. Users will be able to access metadata for each Tune if they know the address, key, and tokenID of the Tune that they want to get metadata for.

#### Setting your metadata on the contract:

There are two main calls to set metadata. The main use case expects you to have an a contract conforming to **IERC721Metadata** as explained above. If you have deployed such a contract, simply call:

`setInheritedMetadata(string memory _key, address _address)`

Where **_key** is the name of your collection and **_address** is the address of the deployed contract. You can call this from any personal wallet you own.

To access the metadata after that, simply call `getMetadata(address _devAddress, string memory _key, uint _tokenID)` where:

- **_devAddress** is the address of your wallet (not the contract) you used to call `setInheritedMetadata` above
- **_key** is the key set above
- **_tokenID** is the corresponding tokenID.

`getMetadata` simply forwards the call to your contract's implementation of `tokenURI()`

If you do not want to create a contract to interact with **TunesMetadata** you can use also use `setDirectMetadata`.

Let's say you want to make a viewer site for Tunes that lets you change the frame color of the Tune on your site. You don't necessarily want to make a new derivative NFT, so instead you could have a button that lets the Tunes owner call:

`setDirectMetadata(string memory _key, uint _tokenID, string memory _data)`

Note that if this is unprotected on your end, anyone can change any tokenID's metadata for your collection. It is your responsibility to gate this how you see fit.


#### Reading metadata from the contract:

To read metadata, you can either use: 

`getMetadata(address _devAddress, string memory _key, uint _tokenID)` 
or 
`getOfficialMetadata(string memory _metadataKeyAlias, uint _tokenID)`

You'll realize that you need to know the exact devAddress and key to use the direct getMetadata call, which isn't useful if you're trying to find what other people have made. That's what official aliases are for!

To get a list of all official aliases:

`getOfficialMetadataAliases()`

This returns a list of official aliases. The aliases should be self explanatory in name, but we will keep a record here as well.

Once you know the alias you'd like to fetch, simply call `getOfficialMetadata(string memory _metadataKeyAlias, uint _tokenID)` to fetch the relevant metadata.

#### More about Official Aliases:

Since anyone can create a metadata collection, it'd be impractical to try to access metadata knowing the dev address and key for everyone who's made a collection. Instead, we've created official aliases - essentially shortcuts to officially approved derivative works.

For example, let's say you made some cover art for Tunes and called `setInheritedMetadata` with your deployed contract address. Instead of needing to know your address and key, the team can simply make an official alias called "coverArt" which will allow anyone to call `getOfficialMetadata("coverArt", <token_id>)` to directly access your metadata.

Please reach out to the team on Discord to get your metadata an official alias. 


